{"map":"{\"version\":3,\"sources\":[\"C:\\\\Users\\\\Admin\\\\Documents\\\\appli react\\\\memory\\\\src\\\\Card.js\",\"C:\\\\Users\\\\Admin\\\\Documents\\\\appli react\\\\memory\\\\src\\\\GuessCount.js\",\"C:\\\\Users\\\\Admin\\\\Documents\\\\appli react\\\\memory\\\\src\\\\HallOfFame.js\",\"C:\\\\Users\\\\Admin\\\\Documents\\\\appli react\\\\memory\\\\src\\\\HighScoreInput.js\",\"C:\\\\Users\\\\Admin\\\\Documents\\\\appli react\\\\memory\\\\src\\\\App.js\",\"C:\\\\Users\\\\Admin\\\\Documents\\\\appli react\\\\memory\\\\src\\\\serviceWorker.js\",\"C:\\\\Users\\\\Admin\\\\Documents\\\\appli react\\\\memory\\\\src\\\\index.js\"],\"names\":[\"Card\",\"_ref\",\"card\",\"feedback\",\"index\",\"onClick\",\"react_default\",\"a\",\"createElement\",\"className\",\"concat\",\"GuessCount\",\"guesses\",\"HallOfFame\",\"entries\",\"map\",\"_ref2\",\"date\",\"id\",\"player\",\"key\",\"HOF_KEY\",\"HOF_MAX_SIZE\",\"HighScoreInput\",\"state\",\"winner\",\"handleWinnerUpdate\",\"event\",\"_this\",\"setState\",\"target\",\"value\",\"toUpperCase\",\"persistWinner\",\"preventDefault\",\"entry\",\"onStored\",\"Date\",\"toLocaleDateString\",\"now\",\"JSON\",\"parse\",\"localStorage\",\"getItem\",\"insertionPoint\",\"findIndex\",\"_ref3\",\"push\",\"splice\",\"length\",\"setItem\",\"stringify\",\"saveHOFEntry\",\"props\",\"onSubmit\",\"this\",\"type\",\"autoComplete\",\"onChange\",\"Component\",\"App\",\"cards\",\"generateCards\",\"currentPair\",\"halloffame\",\"matchedCardIndices\",\"displayHallOfFame\",\"hallOfFame\",\"handleCardClick\",\"handleNewPairClosedBy\",\"result\",\"candidates\",\"shuffle\",\"SIDE\",\"pop\",\"_this$state\",\"indexMatched\",\"includes\",\"_this2\",\"_this$state2\",\"newPair\",\"newGuesses\",\"matched\",\"Object\",\"toConsumableArray\",\"setTimeout\",\"_this3\",\"_this$state3\",\"won\",\"src_GuessCount_0\",\"src_Card_0\",\"getFeedbackForCard\",\"src_HallOfFame_0\",\"src_HighScoreInput_0\",\"Boolean\",\"window\",\"location\",\"hostname\",\"match\",\"ReactDOM\",\"render\",\"src_App_0\",\"document\",\"getElementById\",\"navigator\",\"serviceWorker\",\"ready\",\"then\",\"registration\",\"unregister\"],\"mappings\":\"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\",\"sourcesContent\":[\"import React from 'react'\\r\\nimport PropTypes from 'prop-types'\\r\\nimport './Card.css'\\r\\n\\r\\nconst HIDDEN_SYMBOL = '‚ùì'\\r\\n\\r\\n//fonction card on aura plus qu'a appeler <Card $a,$b,$c,$d/> \\r\\nconst Card = ({ card, feedback, index, onClick }) => ( \\r\\n//comme pas de calcul alors pas de return\\r\\n//card represente le symbole, feedback si la carte est tourne ou pas, index represente la cle de la carte, \\r\\n//onclick est la methode pour retourne donc doit etre declare\\r\\n  <div className={`card ${feedback}`} onClick={() => onClick(index)}>\\r\\n    <span className=\\\"symbol\\\">\\r\\n      {feedback === 'hidden' ? HIDDEN_SYMBOL : card}\\r\\n    </span>\\r\\n  </div>\\r\\n)\\r\\n\\r\\nCard.propTypes = {\\r\\n  card: PropTypes.string.isRequired,\\r\\n  feedback: PropTypes.oneOf([\\r\\n    'hidden',\\r\\n    'justMatched',\\r\\n    'justMismatched',\\r\\n    'visible',\\r\\n  ]).isRequired,\\r\\n  index: PropTypes.number.isRequired,\\r\\n  onClick: PropTypes.func.isRequired,\\r\\n}\\r\\n\\r\\nexport default Card\",\"import React from 'react'\\r\\nimport PropTypes from 'prop-types'\\r\\nimport './GuessCount.css'\\r\\n\\r\\n//fonction GuessCount qui prend un argument guesses et qui l'affiche dans une div\\r\\nconst GuessCount = ({ guesses }) => <div className=\\\"guesses\\\">{guesses}</div>\\r\\n\\r\\nGuessCount.propTypes = {\\r\\n  guesses: PropTypes.number.isRequired,\\r\\n}\\r\\nexport default GuessCount\",\"import PropTypes from 'prop-types'\\r\\nimport React from 'react'\\r\\n\\r\\nimport './HallOfFame.css'\\r\\n\\r\\nconst HallOfFame = ({ entries }) => (\\r\\n  <table className=\\\"hallOfFame\\\">\\r\\n    <tbody>\\r\\n      {entries.map(({ date, guesses, id, player }) => (\\r\\n        <tr key={id}>\\r\\n          <td className=\\\"date\\\">{date}</td>\\r\\n          <td className=\\\"guesses\\\">{guesses}</td>\\r\\n          <td className=\\\"player\\\">{player}</td>\\r\\n        </tr>\\r\\n      ))}\\r\\n    </tbody>\\r\\n  </table>\\r\\n)\\r\\n\\r\\nHallOfFame.propTypes = {\\r\\n  entries: PropTypes.arrayOf(\\r\\n    PropTypes.shape({\\r\\n      date: PropTypes.string.isRequired,\\r\\n      guesses: PropTypes.number.isRequired,\\r\\n      id: PropTypes.number.isRequired,\\r\\n      player: PropTypes.string.isRequired,\\r\\n    })\\r\\n  ).isRequired,\\r\\n}\\r\\n\\r\\nexport default HallOfFame\\r\\n\\r\\n// == Internal helpers ==============================================\\r\\n\\r\\nexport const FAKE_HOF = [\\r\\n  { id: 3, guesses: 18, date: '10/10/2017', player: 'Jane' },\\r\\n  { id: 2, guesses: 23, date: '11/10/2017', player: 'Kevin' },\\r\\n  { id: 1, guesses: 31, date: '06/10/2017', player: 'Louisa' },\\r\\n  { id: 0, guesses: 48, date: '14/10/2017', player: 'Marc' },\\r\\n]\\r\\n\\r\\nconst HOF_KEY = '::Memory::HallofFame'\\r\\nconst HOF_MAX_SIZE = 10\\r\\n\\r\\nexport function saveHOFEntry(entry, onStored) {\\r\\n  entry.date = new Date().toLocaleDateString()\\r\\n  entry.id = Date.now()\\r\\n\\r\\n  const entries = JSON.parse(localStorage.getItem(HOF_KEY) || '[]')\\r\\n  const insertionPoint = entries.findIndex(\\r\\n    ({ guesses }) => guesses >= entry.guesses\\r\\n  )\\r\\n\\r\\n  if (insertionPoint === -1) {\\r\\n    entries.push(entry)\\r\\n  } else {\\r\\n    entries.splice(insertionPoint, 0, entry)\\r\\n  }\\r\\n  if (entries.length > HOF_MAX_SIZE) {\\r\\n    entries.splice(HOF_MAX_SIZE, entries.length)\\r\\n  }\\r\\n\\r\\n  localStorage.setItem(HOF_KEY, JSON.stringify(entries))\\r\\n  onStored(entries)\\r\\n}\",\"import PropTypes from 'prop-types'\\r\\nimport React, { Component } from 'react'\\r\\n\\r\\nimport './HighScoreInput.css'\\r\\n\\r\\nimport { saveHOFEntry } from './HallOfFame'\\r\\n\\r\\nclass HighScoreInput extends Component {\\r\\n   state = { winner: '' }\\r\\n\\r\\n// Arrow fx for binding force le joueur a saisir en MAJ\\r\\nhandleWinnerUpdate = (event) => {\\r\\n  this.setState({ winner: event.target.value.toUpperCase() })\\r\\n}\\r\\n\\r\\n// Arrow fx for binding enregistre le nbr de guesses et le nom du joueur dans le state\\r\\npersistWinner = (event) => {\\r\\n  event.preventDefault()\\r\\n  const newEntry = { guesses: this.props.guesses, player: this.state.winner }\\r\\n  saveHOFEntry(newEntry, this.props.onStored)\\r\\n}\\r\\n\\r\\n  render() {\\r\\n    return (\\r\\n      <form className=\\\"highScoreInput\\\" onSubmit={this.persistWinner}>\\r\\n        <p>\\r\\n          <label>\\r\\n            Bravo ! Entre ton pr√©nom :\\r\\n            <input type=\\\"text\\\" autoComplete=\\\"given-name\\\" value={this.state.winner} onChange={this.handleWinnerUpdate}/>\\r\\n          </label>\\r\\n          <button type=\\\"submit\\\">J‚Äôai gagn√© !</button>\\r\\n        </p>\\r\\n      </form>\\r\\n    )\\r\\n  }\\r\\n}\\r\\n\\r\\nHighScoreInput.propTypes = {\\r\\n  guesses: PropTypes.number.isRequired,\\r\\n  onStored: PropTypes.func.isRequired,\\r\\n}\\r\\n\\r\\nexport default HighScoreInput\",\"import React, { Component } from 'react'\\nimport shuffle from 'lodash.shuffle'\\nimport './App.css'\\nimport Card from './Card'\\nimport GuessCount from './GuessCount'\\nimport HallOfFame from './HallOfFame'\\nimport HighScoreInput from './HighScoreInput'\\n\\n\\n//import jamespot from 'jamespot-user-api'\\n\\n//console.log(jamespot);\\n\\nconst VISUAL_PAUSE_MSECS = 750\\nconst SIDE = 6\\nconst SYMBOLS = 'üòÄüéâüíñüé©üê∂üê±ü¶Ñüê¨üåçüåõüåûüí´üçéüçåüçìüçêüçüüçø'\\n\\nclass App extends Component {\\n  state = {\\n    cards: this.generateCards(),  //tableau des cartes\\n    currentPair: [],              //currentPair represente l'index de la carte selectionne\\n    guesses: 0,                   //nbr d'essai\\n    halloffame: null,             //tableau des scores\\n    matchedCardIndices: [],       //Indice des cartes reussies \\n    \\n  }\\n\\n\\n\\n/*\\n  componentWillMount(){\\n    console.log('mount');\\n\\n    jamespot.user.signIn('antony.meunier@jamespot.com', 'A').then((response) => {\\n      console.log(response);\\n    })\\n  }\\n*/\\n\\n\\n\\n// Arrow fx for binding recupere le tableau des scores\\ndisplayHallOfFame = (hallOfFame) => {\\n  this.setState({ hallOfFame })\\n}\\n\\n  generateCards() {\\n    const result = []\\n    const size = SIDE * SIDE\\n    //melange des symboles\\n    const candidates = shuffle(SYMBOLS)\\n    while (result.length < size) {\\n      //.pop sert a supprimer le dernier element et a le retourne\\n      const card = candidates.pop()\\n      //je rajoute 2 fois les cartes\\n      result.push(card, card)\\n    }\\n    //je remelange la pioche\\n    return shuffle(result)\\n  }\\n\\n\\n// dire si une carte doit etre retourne ou affiche\\n  getFeedbackForCard(index) {  \\n    // je recupere l'indice de la premiere carte currentpair et l'indice des cartes retournees\\n  const { currentPair, matchedCardIndices } = this.state\\n  //.include signifie est ce que le tableau contient l'index\\n  //si l'index de la carte est deja dans la collec match√© grace a la fonction handleclick\\n  const indexMatched = matchedCardIndices.includes(index)\\n\\n  //si il y a une carte ou zero dans mon ancien tableau \\n  if (currentPair.length < 2) {\\n    //si index matched ou si element courant(premier element de currentPair) j'affiche\\n    return indexMatched || index === currentPair[0] ? 'visible' : 'hidden'\\n  }\\n\\n  //pour les deux cartes du tableau current\\n  if (currentPair.includes(index)) {\\n    //si l 'index de la carte selectionne est dans les cartes match√©s alors justMatched sinon justMismatched\\n    return indexMatched ? 'justMatched' : 'justMismatched'\\n\\n  }\\n\\n  return indexMatched ? 'visible' : 'hidden'\\n}\\n\\n\\n\\n  // Arrow fx for binding\\n  //fonction handlecardclick qui prend un index en param\\nhandleCardClick = index => {\\n  //la carte actuelle recupere les states de l'objet actuel\\n  const { currentPair } = this.state\\n\\n  //si 2 carte etaient decouvertes\\n  if (currentPair.length === 2) {\\n    return\\n  }\\n  //si 1 cartes decouverte car dans le passe le tableau etait vide\\n  if (currentPair.length === 0) {\\n    //je rajoute la carte actuelle a currentPair\\n    this.setState({ currentPair: [index] })\\n    return\\n  }\\n  //si je clique sur la deuxieme carte dans mon tableau il y a une carte dans mon tableau current\\n  this.handleNewPairClosedBy(index)\\n}\\n\\n  handleNewPairClosedBy(index) {\\n    const { cards, currentPair, guesses, matchedCardIndices } = this.state\\n\\n    const newPair = [currentPair[0], index]\\n    const newGuesses = guesses + 1\\n    //Verification si les deux cartes sont egales\\n    const matched = cards[newPair[0]] === cards[newPair[1]] && newPair[0]!==newPair[1]\\n    this.setState({ currentPair: newPair, guesses: newGuesses })\\n    if (matched) {\\n      //si c'est les memes cartes je modifie l'indice des cartes match√©s en ajoutant les nouvels indices\\n      this.setState({ matchedCardIndices: [...matchedCardIndices, ...newPair] })\\n    }\\n   \\n    setTimeout(() => this.setState({ currentPair: [] }), VISUAL_PAUSE_MSECS)\\n  }\\n\\n render() {\\n  //au debut du render je dois recuperer les variables locales (le state)\\n  \\n  const { cards, guesses, hallOfFame, matchedCardIndices } = this.state\\n  // won prend la variable vrai si les cartes match√©es sont egales au nbr de carte total\\n  const won = matchedCardIndices.length === cards.length\\n\\n  return (\\n    <div className=\\\"memory\\\">\\n\\n      <GuessCount guesses={guesses} />\\n     {\\n      // j'appelle chacune des images de cards, l'index est instancier automatiquement \\n      //puis j'appelle les composants card un par un et je les instacie \\n      // cards.map represente le changement du tableau cards \\n        cards.map((card, index) => (\\n          <Card\\n            card={card}\\n            feedback={this.getFeedbackForCard(index)}\\n            index={index}\\n            key={index}\\n            onClick={this.handleCardClick}\\n          />\\n        ))\\n      }\\n     \\n          {won && \\n             (hallOfFame ? (<HallOfFame entries={hallOfFame} />) \\n                          : \\n                          (<HighScoreInput guesses={guesses} onStored={this.displayHallOfFame} />))\\n          } \\n         \\n        </div>\\n      )\\n  }\\n}\\n\\nexport default App\",\"// This optional code is used to register a service worker.\\n// register() is not called by default.\\n\\n// This lets the app load faster on subsequent visits in production, and gives\\n// it offline capabilities. However, it also means that developers (and users)\\n// will only see deployed updates on subsequent visits to a page, after all the\\n// existing tabs open on the page have been closed, since previously cached\\n// resources are updated in the background.\\n\\n// To learn more about the benefits of this model and instructions on how to\\n// opt-in, read https://bit.ly/CRA-PWA\\n\\nconst isLocalhost = Boolean(\\n  window.location.hostname === 'localhost' ||\\n    // [::1] is the IPv6 localhost address.\\n    window.location.hostname === '[::1]' ||\\n    // 127.0.0.1/8 is considered localhost for IPv4.\\n    window.location.hostname.match(\\n      /^127(?:\\\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\\n    )\\n);\\n\\nexport function register(config) {\\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\\n    // The URL constructor is available in all browsers that support SW.\\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\\n    if (publicUrl.origin !== window.location.origin) {\\n      // Our service worker won't work if PUBLIC_URL is on a different origin\\n      // from what our page is served on. This might happen if a CDN is used to\\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\\n      return;\\n    }\\n\\n    window.addEventListener('load', () => {\\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\\n\\n      if (isLocalhost) {\\n        // This is running on localhost. Let's check if a service worker still exists or not.\\n        checkValidServiceWorker(swUrl, config);\\n\\n        // Add some additional logging to localhost, pointing developers to the\\n        // service worker/PWA documentation.\\n        navigator.serviceWorker.ready.then(() => {\\n          console.log(\\n            'This web app is being served cache-first by a service ' +\\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\\n          );\\n        });\\n      } else {\\n        // Is not localhost. Just register service worker\\n        registerValidSW(swUrl, config);\\n      }\\n    });\\n  }\\n}\\n\\nfunction registerValidSW(swUrl, config) {\\n  navigator.serviceWorker\\n    .register(swUrl)\\n    .then(registration => {\\n      registration.onupdatefound = () => {\\n        const installingWorker = registration.installing;\\n        if (installingWorker == null) {\\n          return;\\n        }\\n        installingWorker.onstatechange = () => {\\n          if (installingWorker.state === 'installed') {\\n            if (navigator.serviceWorker.controller) {\\n              // At this point, the updated precached content has been fetched,\\n              // but the previous service worker will still serve the older\\n              // content until all client tabs are closed.\\n              console.log(\\n                'New content is available and will be used when all ' +\\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\\n              );\\n\\n              // Execute callback\\n              if (config && config.onUpdate) {\\n                config.onUpdate(registration);\\n              }\\n            } else {\\n              // At this point, everything has been precached.\\n              // It's the perfect time to display a\\n              // \\\"Content is cached for offline use.\\\" message.\\n              console.log('Content is cached for offline use.');\\n\\n              // Execute callback\\n              if (config && config.onSuccess) {\\n                config.onSuccess(registration);\\n              }\\n            }\\n          }\\n        };\\n      };\\n    })\\n    .catch(error => {\\n      console.error('Error during service worker registration:', error);\\n    });\\n}\\n\\nfunction checkValidServiceWorker(swUrl, config) {\\n  // Check if the service worker can be found. If it can't reload the page.\\n  fetch(swUrl)\\n    .then(response => {\\n      // Ensure service worker exists, and that we really are getting a JS file.\\n      const contentType = response.headers.get('content-type');\\n      if (\\n        response.status === 404 ||\\n        (contentType != null && contentType.indexOf('javascript') === -1)\\n      ) {\\n        // No service worker found. Probably a different app. Reload the page.\\n        navigator.serviceWorker.ready.then(registration => {\\n          registration.unregister().then(() => {\\n            window.location.reload();\\n          });\\n        });\\n      } else {\\n        // Service worker found. Proceed as normal.\\n        registerValidSW(swUrl, config);\\n      }\\n    })\\n    .catch(() => {\\n      console.log(\\n        'No internet connection found. App is running in offline mode.'\\n      );\\n    });\\n}\\n\\nexport function unregister() {\\n  if ('serviceWorker' in navigator) {\\n    navigator.serviceWorker.ready.then(registration => {\\n      registration.unregister();\\n    });\\n  }\\n}\\n\",\"import React from 'react';\\nimport ReactDOM from 'react-dom';\\nimport App from './App';\\nimport * as serviceWorker from './serviceWorker';\\n\\nReactDOM.render(<App />, document.getElementById('root'));\\n\\n// If you want your app to work offline and load faster, you can change\\n// unregister() to register() below. Note this comes with some pitfalls.\\n// Learn more about service workers: https://bit.ly/CRA-PWA\\nserviceWorker.unregister();\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[,,,,,,,,,,,function(e,t,a){e.exports=a(21)},,,,,function(e,t,a){},function(e,t,a){},function(e,t,a){},function(e,t,a){},function(e,t,a){},function(e,t,a){\"use strict\";a.r(t);var n=a(0),r=a.n(n),s=a(9),c=a.n(s),i=a(10),l=a(1),o=a(2),u=a(4),d=a(3),m=a(5),h=a(6),f=a.n(h),p=(a(16),a(17),function(e){var t=e.card,a=e.feedback,n=e.index,s=e.onClick;return r.a.createElement(\"div\",{className:\"card \".concat(a),onClick:function(){return s(n)}},r.a.createElement(\"span\",{className:\"symbol\"},\"hidden\"===a?\"\\u2753\":t))}),g=(a(18),function(e){var t=e.guesses;return r.a.createElement(\"div\",{className:\"guesses\"},t)}),v=(a(19),function(e){var t=e.entries;return r.a.createElement(\"table\",{className:\"hallOfFame\"},r.a.createElement(\"tbody\",null,t.map(function(e){var t=e.date,a=e.guesses,n=e.id,s=e.player;return r.a.createElement(\"tr\",{key:n},r.a.createElement(\"td\",{className:\"date\"},t),r.a.createElement(\"td\",{className:\"guesses\"},a),r.a.createElement(\"td\",{className:\"player\"},s))})))}),y=\"::Memory::HallofFame\",b=10;a(20);var C=function(e){function t(){var e,a;Object(l.a)(this,t);for(var n=arguments.length,r=new Array(n),s=0;s<n;s++)r[s]=arguments[s];return(a=Object(u.a)(this,(e=Object(d.a)(t)).call.apply(e,[this].concat(r)))).state={winner:\"\"},a.handleWinnerUpdate=function(e){a.setState({winner:e.target.value.toUpperCase()})},a.persistWinner=function(e){e.preventDefault(),function(e,t){e.date=(new Date).toLocaleDateString(),e.id=Date.now();var a=JSON.parse(localStorage.getItem(y)||\"[]\"),n=a.findIndex(function(t){return t.guesses>=e.guesses});-1===n?a.push(e):a.splice(n,0,e),a.length>b&&a.splice(b,a.length),localStorage.setItem(y,JSON.stringify(a)),t(a)}({guesses:a.props.guesses,player:a.state.winner},a.props.onStored)},a}return Object(m.a)(t,e),Object(o.a)(t,[{key:\"render\",value:function(){return r.a.createElement(\"form\",{className:\"highScoreInput\",onSubmit:this.persistWinner},r.a.createElement(\"p\",null,r.a.createElement(\"label\",null,\"Bravo ! Entre ton pr\\xe9nom :\",r.a.createElement(\"input\",{type:\"text\",autoComplete:\"given-name\",value:this.state.winner,onChange:this.handleWinnerUpdate})),r.a.createElement(\"button\",{type:\"submit\"},\"J\\u2019ai gagn\\xe9 !\")))}}]),t}(n.Component),w=function(e){function t(){var e,a;Object(l.a)(this,t);for(var n=arguments.length,r=new Array(n),s=0;s<n;s++)r[s]=arguments[s];return(a=Object(u.a)(this,(e=Object(d.a)(t)).call.apply(e,[this].concat(r)))).state={cards:a.generateCards(),currentPair:[],guesses:0,halloffame:null,matchedCardIndices:[]},a.displayHallOfFame=function(e){a.setState({hallOfFame:e})},a.handleCardClick=function(e){var t=a.state.currentPair;2!==t.length&&(0!==t.length?a.handleNewPairClosedBy(e):a.setState({currentPair:[e]}))},a}return Object(m.a)(t,e),Object(o.a)(t,[{key:\"generateCards\",value:function(){for(var e=[],t=f()(\"\\ud83d\\ude00\\ud83c\\udf89\\ud83d\\udc96\\ud83c\\udfa9\\ud83d\\udc36\\ud83d\\udc31\\ud83e\\udd84\\ud83d\\udc2c\\ud83c\\udf0d\\ud83c\\udf1b\\ud83c\\udf1e\\ud83d\\udcab\\ud83c\\udf4e\\ud83c\\udf4c\\ud83c\\udf53\\ud83c\\udf50\\ud83c\\udf5f\\ud83c\\udf7f\");e.length<36;){var a=t.pop();e.push(a,a)}return f()(e)}},{key:\"getFeedbackForCard\",value:function(e){var t=this.state,a=t.currentPair,n=t.matchedCardIndices.includes(e);return a.length<2?n||e===a[0]?\"visible\":\"hidden\":a.includes(e)?n?\"justMatched\":\"justMismatched\":n?\"visible\":\"hidden\"}},{key:\"handleNewPairClosedBy\",value:function(e){var t=this,a=this.state,n=a.cards,r=a.currentPair,s=a.guesses,c=a.matchedCardIndices,l=[r[0],e],o=s+1,u=n[l[0]]===n[l[1]]&&l[0]!==l[1];this.setState({currentPair:l,guesses:o}),u&&this.setState({matchedCardIndices:[].concat(Object(i.a)(c),l)}),setTimeout(function(){return t.setState({currentPair:[]})},750)}},{key:\"render\",value:function(){var e=this,t=this.state,a=t.cards,n=t.guesses,s=t.hallOfFame,c=t.matchedCardIndices.length===a.length;return r.a.createElement(\"div\",{className:\"memory\"},r.a.createElement(g,{guesses:n}),a.map(function(t,a){return r.a.createElement(p,{card:t,feedback:e.getFeedbackForCard(a),index:a,key:a,onClick:e.handleCardClick})}),c&&(s?r.a.createElement(v,{entries:s}):r.a.createElement(C,{guesses:n,onStored:this.displayHallOfFame})))}}]),t}(n.Component);Boolean(\"localhost\"===window.location.hostname||\"[::1]\"===window.location.hostname||window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));c.a.render(r.a.createElement(w,null),document.getElementById(\"root\")),\"serviceWorker\"in navigator&&navigator.serviceWorker.ready.then(function(e){e.unregister()})}],[[11,1,2]]]);","extractedComments":[]}